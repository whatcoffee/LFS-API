<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>LFS API Reference</title>

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #f8f8f2;
  background-color: #272822;
}
.highlight .err {
  color: #151515;
  background-color: #ac4142;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #505050;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #d0d0d0;
}
.highlight .p, .highlight .pi {
  color: #d0d0d0;
}
.highlight .gi {
  color: #90a959;
}
.highlight .gd {
  color: #ac4142;
}
.highlight .gh {
  color: #6a9fb5;
  background-color: #151515;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #aa759f;
}
.highlight .kc {
  color: #d28445;
}
.highlight .kt {
  color: #d28445;
}
.highlight .kd {
  color: #d28445;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #90a959;
}
.highlight .sr {
  color: #75b5aa;
}
.highlight .si {
  color: #8f5536;
}
.highlight .se {
  color: #8f5536;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #6a9fb5;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #90a959;
}
.highlight .ss {
  color: #90a959;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all.js"></script>
  </head>

  <body class="index" data-languages="[&quot;lua&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <!--img src="images/logo.png" /-->
        <div class="lang-selector">
              <a href="#" data-language-name="lua">lua</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
            <li><a href="https://github.com/ikCourage/LFS" target="_blank">github</a></li>
            <li><a href="https://git.oschina.net/ikCourage/LFS_FREE" target="_blank">git@osc</a></li>
            <li><a href="http://github.com/tripit/slate" target="_blank">Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="introduction">Introduction</h1>

<p>Welcome LFS API</p>

<p>LFS 是非常非常快的文件系统，可以同时存储海量大文件和小文件，高并发。</p>

<p>许多存储方案或者优于存储大文件，或者优于存储小文件，在 LFS 中则一视同仁。所以既可以用来存储视频音乐，也可以用来存储图片。</p>

<p>使用 LFS 可以轻易构建出一个倒排：<a href="#InvertFile">example</a>。</p>

<p>LFS 的有趣之处在于，<a href="#DataFile">DataFile</a> 具有类似数组的特性，看起来就像是控制数组而不是数据。</p>

<p>LFS 使用 lua 作为脚本语言（快并且简单），可以提供更细致的逻辑处理。</p>

<p>共有 <a href="#LFS">LFS</a>，<a href="#vars">vars</a>, <a href="#out">out</a>, <a href="#buffer">buffer</a> 这几个全局对象。（清晰明了）</p>

<p>链接：<a href="https://github.com/ikCourage/LFS" target="_blank">github</a> <a href="https://git.oschina.net/ikCourage/LFS_FREE" target="_blank">git@osc</a></p>

<h1 id="LFS">LFS</h1>

<h3 id="lfs">LFS 中定义的类</h3>

<table><thead>
<tr>
<th>Class</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td><a href="#DataFile">DataFile</a></td>
<td>普通的数据文件：提供原始数据的读写（最常用的类, 几乎所有的操作都基于此）</td>
</tr>
<tr>
<td><a href="#UniqueFile">UniqueFile</a></td>
<td>唯一文件：通过 IndexKey 来标识记录的唯一性</td>
</tr>
<tr>
<td><a href="#InvertFile">InvertFile</a></td>
<td>倒排文件：用来存储指向一个 [相同属性] 的所有记录 ID</td>
</tr>
<tr>
<td><a href="#IndexKey">IndexKey</a></td>
<td>索引 key：将字符串或字节数组转换成可被索引的哈希</td>
</tr>
<tr>
<td><a href="#ByteArray">ByteArray</a></td>
<td>字节数组：提供对原始字节的高级读写</td>
</tr>
</tbody></table>

<h1 id="vars">vars <em><code>global</code></em></h1>

<p>[read-only] 客户端传入的变量数组，下标从 0 开始。</p>

<h2 id="vars_length">length <em><code>property</code></em></h2>

<p><code class="prettyprint">length:uint</code> [read-only]</p>

<p>变量数组的长度。</p>

<h2 id="vars_getLength">getLength</h2>

<p><code class="prettyprint">getLength(index:uint):uint</code></p>

<p>返回数组中 index 指定位置的变量长度。</p>

<h2 id="vars_getType">getType</h2>

<p><code class="prettyprint">getType(index:uint):int</code></p>

<p>返回数组中 index 指定位置的变量类型。</p>

<table><thead>
<tr>
<th>Return</th>
<th>Type</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>byte</td>
</tr>
<tr>
<td>-1</td>
<td>ubyte</td>
</tr>
<tr>
<td>2</td>
<td>short</td>
</tr>
<tr>
<td>3</td>
<td>ushort</td>
</tr>
<tr>
<td>4</td>
<td>int</td>
</tr>
<tr>
<td>5</td>
<td>uint</td>
</tr>
<tr>
<td>6</td>
<td>float</td>
</tr>
<tr>
<td>7</td>
<td>double</td>
</tr>
<tr>
<td>8</td>
<td>long</td>
</tr>
<tr>
<td>-4</td>
<td>String</td>
</tr>
<tr>
<td>-5</td>
<td>StringBytes</td>
</tr>
<tr>
<td>-3</td>
<td>bytes</td>
</tr>
<tr>
<td>-2</td>
<td>Boolean</td>
</tr>
<tr>
<td>0</td>
<td>null</td>
</tr>
</tbody></table>

<h1 id="buffer">buffer <em><code>global</code></em></h1>

<p><code class="prettyprint">buffer</code> 是一个 ByteArray 对象。</p>

<p>当从 DataFile 等文件中读取文档时，会自动读入到 <code class="prettyprint">buffer</code> 中，然后通过 ByteArray 的方法对数据进行访问。</p>

<h2 id="buffer_sizeTotal">sizeTotal <em><code>property</code></em></h2>

<p><code class="prettyprint">sizeTotal:ulong</code> [read-only]</p>

<p>当从 DataFile 等文件中读取文档时，<code class="prettyprint">sizeTotal</code> 会返回文档的总大小。</p>

<h1 id="out">out <em><code>global</code></em></h1>

<p>输出字节流：用来将数据返回给客户端。</p>

<h2 id="out_setState">setState</h2>

<p><code class="prettyprint">setState(state:int):void</code></p>

<p>设置返回给客户端的状态。（0 为成功）</p>

<p>通过设置 <code class="prettyprint">state</code> 来简便指定当前执行是否成功。</p>

<aside class="notice">

<code>state</code> 为用户自己设定的状态，不要与客户端的 <code>status</code> 弄混。（<code>status</code> 表示语句是否执行成功。若语法错误或运行时错误则 <code>status</code> 不为 0）

</aside>

<h2 id="out_getState">getState</h2>

<p><code class="prettyprint">getState():int</code></p>

<p>返回当前的执行状态。若从未设置过 <code class="prettyprint">state</code>，则一直为默认值：0。</p>

<h2 id="out_setPosition">setPosition</h2>

<blockquote>
<p>修改一个已经存在于 <code class="prettyprint">out</code> 中的值</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">resultState_position</span> <span class="o">=</span> <span class="n">out</span><span class="p">:</span><span class="n">getPosition</span><span class="p">();</span> <span class="c1">-- 首先记录下 position</span>
<span class="n">out</span><span class="p">:</span><span class="n">putInt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">-- 占位（此时尚未知道执行结果。假设返回的数据结构要求 resultState 放在头部）</span>
<span class="n">out</span><span class="p">:</span><span class="n">putString</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="c1">-- 省略部分语句</span>
<span class="kd">local</span> <span class="n">current_position</span> <span class="o">=</span> <span class="n">out</span><span class="p">:</span><span class="n">getPosition</span><span class="p">();</span> <span class="c1">-- 记录下当前的 position</span>
<span class="n">out</span><span class="p">:</span><span class="n">setPosition</span><span class="p">(</span><span class="n">resultState_position</span><span class="p">);</span> <span class="c1">-- 设置回需要添加头的位置</span>
<span class="n">out</span><span class="p">:</span><span class="n">putInt</span><span class="p">(</span><span class="n">resultState</span><span class="p">);</span> <span class="c1">-- 将 resultState 写入之前占位的地方</span>
<span class="n">out</span><span class="p">:</span><span class="n">setPosition</span><span class="p">(</span><span class="n">current_position</span><span class="p">);</span> <span class="c1">-- 重新设置回最后的位置，因为接下来还需要返回其他内容</span>
<span class="c1">-- 省略部分语句</span>
<span class="n">out</span><span class="p">:</span><span class="n">putString</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">setPosition(position:uint):void</code></p>

<p>设置当前的偏移。</p>

<aside class="warning">

请谨慎使用此方法。此方法只用来修改已经添加进 <code>out</code> 中的值。请务必确保 position 不会打乱 <code>out</code> 中的字节。

</aside>

<h2 id="out_getPosition">getPosition</h2>

<p><code class="prettyprint">getPosition():uint</code></p>

<p>返回当前的偏移位置。</p>

<h2 id="out_putString">putString</h2>

<p><code class="prettyprint">putString(str:Bytes, offset:uint = 0, length:uint = 0):void</code></p>

<p>类似：<a href="#ByteArray_writeBytes">ByteArray:writeBytes</a></p>

<h2 id="out_putStringBytes">putStringBytes</h2>

<p><code class="prettyprint">putStringBytes(strBytes:Bytes, offset:uint = 0, length:uint = 0):void</code></p>

<p>类似：<a href="#ByteArray_writeBytes">ByteArray:writeBytes</a></p>

<h2 id="out_putBytes">putBytes</h2>

<p><code class="prettyprint">putBytes(bytes:Bytes, offset:uint = 0, length:uint = 0):void</code></p>

<p>类似：<a href="#ByteArray_writeBytes">ByteArray:writeBytes</a></p>

<h2 id="out_putBoolean">putBoolean</h2>

<p><code class="prettyprint">putBoolean(value:Boolean):void</code></p>

<h2 id="out_putByte">putByte</h2>

<p><code class="prettyprint">putByte(value:byte):void</code></p>

<h2 id="out_putUByte">putUByte</h2>

<p><code class="prettyprint">putUByte(value:ubyte):void</code></p>

<h2 id="out_putShort">putShort</h2>

<p><code class="prettyprint">putShort(value:short):void</code></p>

<h2 id="out_putUShort">putUShort</h2>

<p><code class="prettyprint">putUShort(value:ushort):void</code></p>

<h2 id="out_putInt">putInt</h2>

<p><code class="prettyprint">putInt(value:int):void</code></p>

<h2 id="out_putUInt">putUInt</h2>

<p><code class="prettyprint">putUInt(value:uint):void</code></p>

<h2 id="out_putLong">putLong</h2>

<p><code class="prettyprint">putLong(value:long):void</code></p>

<h2 id="out_putFloat">putFloat</h2>

<p><code class="prettyprint">putFloat(value:float):void</code></p>

<h2 id="out_putDouble">putDouble</h2>

<p><code class="prettyprint">putDouble(value:double):void</code></p>

<h2 id="out_putNull">putNull</h2>

<p><code class="prettyprint">putNull():void</code></p>

<h1 id="DataFile">DataFile <em><code>Class</code></em></h1>

<p>普通的数据文件：提供原始数据的读写（最常用的类, 几乎所有的操作都基于此）</p>

<p>一个 DataFile 最多可以存储 2^32 - 1 个记录（每个记录即表示为一个独立的文档，所有的“记录”或“文档”表示相同的概念）</p>

<h2 id="DataFile_new">new <em><code>constructor</code></em></h2>

<p><code class="prettyprint">new(path:String = null):DataFile</code></p>

<h2 id="DataFile_open">open</h2>

<blockquote>
<p>打开文件</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">photosFile</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">DataFile</span><span class="p">.</span><span class="n">new</span><span class="p">();</span>
<span class="n">photosFile</span><span class="p">:</span><span class="n">open</span><span class="p">(</span><span class="s2">"app/photos"</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">open(path:String):void</code></p>

<p>打开文件</p>

<h2 id="DataFile_setOne">setOne</h2>

<blockquote>
<p>该操作等同于</p>
</blockquote>
<pre class="highlight lua"><code><span class="k">if</span> <span class="p">(</span><span class="n">myFile</span><span class="p">:</span><span class="n">getTotalFile</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">then</span><span class="p">;</span>
    <span class="n">myFile</span><span class="p">:</span><span class="n">write</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">-- 占用一个空的记录</span>
    <span class="n">myFile</span><span class="p">:</span><span class="n">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">-- 删除该记录，用来保证 getFileLength 的值是正确的</span>
<span class="k">end</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">setOne(value:Boolean):void</code></p>

<p>设置文档 id 是否跳过 0 从 1 开始。</p>

<aside class="notice">

如果文档 id 需要添加进倒排 <a href="#InvertFile">InvertFile</a> 中，应设为 <code>true</code>。

</aside>

<h2 id="DataFile_setSize">setSize</h2>

<p><code class="prettyprint">setSize(id:long, sizeTotal:ulong, sizeBlockMin:uint = 0, flag:uint = 0):long</code></p>

<p>根据 id 设置文档的大小，返回真实的文档 id</p>

<p>参见 <a href="#DataFile_write">write</a></p>

<h2 id="DataFile_write">write</h2>

<blockquote>
<p>追加一个图片文档</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">photoBytes</span> <span class="o">=</span> <span class="n">vars</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">-- 从传入的数组中取出图片数据</span>
<span class="kd">local</span> <span class="n">id</span> <span class="o">=</span> <span class="n">photosFile</span><span class="p">:</span><span class="n">write</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">photoBytes</span><span class="p">);</span>
<span class="n">out</span><span class="p">:</span><span class="n">putLong</span><span class="p">(</span><span class="n">id</span><span class="p">);</span> <span class="c1">-- 返回文档 id</span>
</code></pre>

<blockquote>
<p>更新文档</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">text</span> <span class="o">=</span> <span class="s2">"new document"</span><span class="p">;</span>
<span class="kd">local</span> <span class="n">id</span> <span class="o">=</span> <span class="n">myFile</span><span class="p">:</span><span class="n">write</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">text</span> <span class="o">=</span> <span class="s2">"update text"</span><span class="p">;</span>
<span class="n">id</span> <span class="o">=</span> <span class="n">myFile</span><span class="p">:</span><span class="n">write</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">-- result: "new updatent"</span>
</code></pre>

<p><code class="prettyprint">write(id:long, buffer:byte[], bufferLength:ulong = MAX, offset:ulong = 0, sizeBlockMin:uint = 0, flag:uint = 0):long</code></p>

<p>根据 id 写入数据，并返回真实的记录 id（0 &lt;= id &lt; 2^32），如果返回的 id &lt; 0 则表示失败。</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>id</td>
<td>0</td>
<td>不能为空（-1 &lt;= id &lt; 2^32），-1 表示写入新的记录</td>
</tr>
<tr>
<td>buffer</td>
<td>null</td>
<td>不能为空。如果为空，此时将写入空的记录，如果原来该记录存在数据，将会被删除</td>
</tr>
<tr>
<td>bufferLength</td>
<td>MAX</td>
<td>默认等于 buffer.length（0 &lt;= bufferLength &lt;= buffer.length）</td>
</tr>
<tr>
<td>offset</td>
<td>0</td>
<td>起始偏移（注意：这是 id 指向的记录的偏移，而不是 buffer 的偏移）</td>
</tr>
<tr>
<td>sizeBlockMin</td>
<td>0</td>
<td>如果当前需要写入的数据长度小于 sizeBlockMin，则用字节 0 补齐（相当于为将要写的 block 分配可用空间，如果此记录的数据长度频繁增长，将会有效提高写入效率。比如：倒排文件(InvertFile)就是一个非常典型的用例）</td>
</tr>
<tr>
<td>flag</td>
<td>0</td>
<td>操作标识，有效值为 0, 1, 2, 3</td>
</tr>
</tbody></table>

<h3 id="flag">flag</h3>

<aside class="warning">

flag 应该成对使用：<code>0 :: 2 or 1 :: 3</code>，或者直接简单粗暴的使用 <b>2</b> or <b>3</b>

</aside>

<table><thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>0</td>
<td>先删除旧的数据，然后写入新的数据</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>在 0 的基础上覆盖写入数据。如果新的数据大于原来的数据，溢出的内容会写入到溢出的 block 里；但是，为了记录溢出的指针，旧的数据会产生数据迁移。（如果数据溢出频繁，应选择 3 的方式）</td>
</tr>
<tr>
<td>1</td>
<td>先删除旧的数据，然后写入新的数据，但会额外记录一个溢出块的指针（即使此时数据尚未溢出，也会记录一个空的指针）</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>在 1 的基础上覆盖写入数据。不同于 2 的是，此时不会涉及到旧数据的迁移，因为，在 1 的基础上已经分配了溢出指针的空间</td>
</tr>
</tbody></table>

<h2 id="DataFile_read">read</h2>

<blockquote>
<p>读取一个图片文档</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">local</span> <span class="n">state</span> <span class="o">=</span> <span class="n">photosFile</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">then</span><span class="p">;</span> <span class="c1">-- 判断是否存在数据</span>
    <span class="n">out</span><span class="p">:</span><span class="n">putBytes</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span> <span class="c1">-- 返回图片内容</span>
<span class="k">end</span><span class="p">;</span>
</code></pre>

<blockquote>
<p>获取文档的总大小</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">state</span> <span class="o">=</span> <span class="n">photosFile</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">then</span><span class="p">;</span>
    <span class="n">out</span><span class="p">:</span><span class="n">putInt</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">sizeTotal</span><span class="p">);</span> <span class="c1">-- 文档的总大小可以通过 buffer.sizeTotal 获取到</span>
    <span class="n">out</span><span class="p">:</span><span class="n">putInt</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">length</span><span class="p">);</span> <span class="c1">-- 本次调用 read 读取的真正长度，buffer.length &lt;= sizeMaxRead</span>
<span class="k">end</span><span class="p">;</span>
</code></pre>

<blockquote>
<p>判断该记录是否为空，或者是否已经删除</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">state</span> <span class="o">=</span> <span class="n">photosFile</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">-- 最多仅读取 1 个字节</span>
<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">then</span><span class="p">;</span>
    <span class="c1">-- 该记录为空</span>
<span class="k">elseif</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="k">then</span><span class="p">;</span>
    <span class="c1">-- 该记录已经删除</span>
<span class="k">end</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">read(id:long, offset:ulong = 0, sizeMaxRead:uint = 0):int</code></p>

<p>根据记录 id 读取数据，返回成功或失败</p>

<aside class="notice">

读取出的内容缓存在全局变量 <a href="#buffer">buffer</a> 中

</aside>

<table><thead>
<tr>
<th>Parameter</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>id</td>
<td>0</td>
<td>文档 id（0 &lt;= id &lt; 2^32）</td>
</tr>
<tr>
<td>offset</td>
<td>0</td>
<td>文档内的起始偏移，从此位置开始读取数据</td>
</tr>
<tr>
<td>sizeMaxRead</td>
<td>0</td>
<td>如果不为 0 则最多读取 sizeMaxRead 的数据（因为文档的总大小可能并不大于 sizeMaxRead）</td>
</tr>
</tbody></table>

<table><thead>
<tr>
<th>Return</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>成功</td>
</tr>
<tr>
<td>0</td>
<td>成功，但这是一个空记录，数据长度为 0</td>
</tr>
<tr>
<td>-7</td>
<td>该记录已经删除</td>
</tr>
<tr>
<td>-2</td>
<td>id 不合法，超出有效范围（0 &lt;= id &lt; 2^32）</td>
</tr>
<tr>
<td>-4</td>
<td>通过 open 打开的文件不存在</td>
</tr>
</tbody></table>

<h2 id="DataFile_remove">remove</h2>

<blockquote>
<p>删除一个图片</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">id</span> <span class="o">=</span> <span class="n">vars</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">-- 从传入的数组中取出需要删除的图片 id</span>
<span class="kd">local</span> <span class="n">state</span> <span class="o">=</span> <span class="n">photosFile</span><span class="p">:</span><span class="n">remove</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
<span class="n">out</span><span class="p">:</span><span class="n">putInt</span><span class="p">(</span><span class="n">state</span><span class="p">);</span> <span class="c1">-- 返回删除的状态</span>
</code></pre>

<p><code class="prettyprint">remove(id:long):int</code></p>

<p>删除记录</p>

<aside class="notice">

已删除的文档空间并不会立刻回收

</aside>

<table><thead>
<tr>
<th>Return</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>成功</td>
</tr>
<tr>
<td>-7</td>
<td>该记录已经删除</td>
</tr>
<tr>
<td>-2</td>
<td>id 不合法，超出有效范围（0 &lt;= id &lt; 2^32）</td>
</tr>
<tr>
<td>-4</td>
<td>通过 open 打开的文件不存在</td>
</tr>
</tbody></table>

<h2 id="DataFile_getTotalFile">getTotalFile</h2>

<blockquote>
<p>获取 &ldquo;app/photos&rdquo; 里的总文档数量</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">photosFile</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">DataFile</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="s2">"app/photos"</span><span class="p">);</span>
<span class="n">out</span><span class="p">:</span><span class="n">putInt</span><span class="p">(</span><span class="n">photosFile</span><span class="p">:</span><span class="n">getTotalFile</span><span class="p">());</span> <span class="c1">-- 返回总文档数量</span>
</code></pre>

<p><code class="prettyprint">getTotalFile():uint</code></p>

<p>返回总文档数量（包含已经删除的）</p>

<h2 id="DataFile_getFileLength">getFileLength</h2>

<blockquote>
<p>获取 &ldquo;app/photos&rdquo; 里的有效文档数量</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">photosFile</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">DataFile</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="s2">"app/photos"</span><span class="p">);</span>
<span class="n">out</span><span class="p">:</span><span class="n">putInt</span><span class="p">(</span><span class="n">photosFile</span><span class="p">:</span><span class="n">getFileLength</span><span class="p">());</span> <span class="c1">-- 返回有效文档数量</span>
</code></pre>

<p><code class="prettyprint">getFileLength():uint</code></p>

<p>返回有效文档数量</p>

<h2 id="DataFile_getFileLengthDeleted">getFileLengthDeleted</h2>

<blockquote>
<p>获取 &ldquo;app/photos&rdquo; 里的已经删除的文档数量</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">photosFile</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">DataFile</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="s2">"app/photos"</span><span class="p">);</span>
<span class="n">out</span><span class="p">:</span><span class="n">putInt</span><span class="p">(</span><span class="n">photosFile</span><span class="p">:</span><span class="n">getFileLengthDeleted</span><span class="p">());</span> <span class="c1">-- 返回已经删除的文档数量</span>
</code></pre>

<p><code class="prettyprint">getFileLengthDeleted():uint</code></p>

<p>返回已经删除的文档数量</p>

<h2 id="DataFile_indexOf">indexOf</h2>

<p><code class="prettyprint">indexOf(bytes:Bytes, fromIndex:uint = 0, endIndex:uint = MAX, length:uint = MAX, offset:ulong = 0, strict:Boolean = false):long</code></p>

<p>从前向后搜索每个文档，返回匹配的文档 id，如果 id &lt; 0 则没有找到匹配的文档。</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>bytes</td>
<td>nil</td>
<td>匹配的内容</td>
</tr>
<tr>
<td>fromIndex</td>
<td>0</td>
<td>搜索的开始位置（开始文档 id）。默认为第一个文档。</td>
</tr>
<tr>
<td>endIndex</td>
<td>MAX</td>
<td>搜索的结束位置（结束文档 id）。默认为最后一个文档。</td>
</tr>
<tr>
<td>length</td>
<td>MAX</td>
<td>bytes 的范围：bytes[0 - length]</td>
</tr>
<tr>
<td>offset</td>
<td>0</td>
<td>文档中从 offset 位置开始匹配 bytes[0 - length]</td>
</tr>
<tr>
<td>strict</td>
<td>false</td>
<td>是否严格检查 sizeTotal 和 length 相等。（只有 offset 为 0 时才有意义）</td>
</tr>
</tbody></table>

<h2 id="DataFile_lastIndexOf">lastIndexOf</h2>

<p><code class="prettyprint">lastIndexOf(bytes:Bytes, fromIndex:uint = 0, endIndex:uint = MAX, length:uint = MAX, offset:ulong = 0, strict:Boolean = false):long</code></p>

<p>从后向前搜索每个文档，返回匹配的文档 id，如果 id &lt; 0 则没有找到匹配的文档。</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>bytes</td>
<td>nil</td>
<td>匹配的内容</td>
</tr>
<tr>
<td>fromIndex</td>
<td>MAX</td>
<td>搜索的开始位置（开始文档 id）。默认为最后一个文档。</td>
</tr>
<tr>
<td>endIndex</td>
<td>0</td>
<td>搜索的结束位置（结束文档 id）。默认为第一个文档。</td>
</tr>
<tr>
<td>length</td>
<td>MAX</td>
<td>bytes 的范围：bytes[0 - length]</td>
</tr>
<tr>
<td>offset</td>
<td>0</td>
<td>文档中从 offset 位置开始匹配 bytes[0 - length]</td>
</tr>
<tr>
<td>strict</td>
<td>false</td>
<td>是否严格检查 sizeTotal 和 length 相等。（只有 offset 为 0 时才有意义）</td>
</tr>
</tbody></table>

<h2 id="DataFile_close">close</h2>

<blockquote>
<p>关闭打开的文件</p>
</blockquote>
<pre class="highlight lua"><code><span class="n">myFile</span><span class="p">:</span><span class="n">close</span><span class="p">();</span>
<span class="n">myFile</span><span class="p">:</span><span class="n">open</span><span class="p">(</span><span class="s2">"app/photos"</span><span class="p">);</span> <span class="c1">-- 打开其他文件</span>
</code></pre>

<p><code class="prettyprint">close():void</code></p>

<p>关闭已经打开的文件，然后可以重新打开其他文件</p>

<h2 id="DataFile_clear">clear</h2>

<blockquote>
<p>清空 DataFile 对象</p>
</blockquote>
<pre class="highlight lua"><code><span class="n">myFile</span><span class="p">:</span><span class="n">clear</span><span class="p">();</span> <span class="c1">-- 清空 DataFile 占用的资源</span>
<span class="n">myFile</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">;</span> <span class="c1">-- 彻底释放 myFile 占用的所有资源</span>
</code></pre>

<p><code class="prettyprint">clear():void</code></p>

<p>清空 DataFile，这将关闭已经打开的文件并释放内存</p>

<aside class="notice">

一旦使用完该实例之后，都需要进行清空，这是良好的习惯，并且也有助于提高执行效率。

</aside>

<h1 id="UniqueFile">UniqueFile <em><code>Class</code></em></h1>

<p>唯一文件（哈希文件）：利用 IndexKey 生成的哈希来快速访问指向的文档</p>

<p>UniqueFile 的用途：</p>

<ul>
<li>避免重复记录（唯一约束）</li>
<li>提高记录的检索速度（生成索引）</li>
<li>用来存储 key-&gt;value</li>
</ul>

<h2 id="UniqueFile_new">new <em><code>constructor</code></em></h2>

<p><code class="prettyprint">new(path:String = null):UniqueFile</code></p>

<h2 id="UniqueFile_open">open</h2>

<blockquote>
<p>打开文件</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">dictFile</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">UniqueFile</span><span class="p">.</span><span class="n">new</span><span class="p">();</span>
<span class="n">dictFile</span><span class="p">:</span><span class="n">open</span><span class="p">(</span><span class="s2">"app/dict"</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">open(path:String):void</code></p>

<p>打开文件</p>

<h2 id="UniqueFile_write">write</h2>

<blockquote>
<p>创建一个字典，启用唯一约束，避免存储相同的词汇（线程安全）</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">indexKey</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">IndexKey</span><span class="p">.</span><span class="n">new</span><span class="p">();</span>
<span class="n">indexKey</span><span class="p">:</span><span class="n">setKey</span><span class="p">(</span><span class="s2">"running man"</span><span class="p">);</span>
<span class="kd">local</span> <span class="n">id</span> <span class="o">=</span> <span class="n">dictFile</span><span class="p">:</span><span class="n">write</span><span class="p">(</span><span class="n">indexKey</span><span class="p">,</span> <span class="s2">"奔跑吧兄弟"</span><span class="p">);</span>
<span class="kd">local</span> <span class="n">id2</span> <span class="o">=</span> <span class="n">dictFile</span><span class="p">:</span><span class="n">write</span><span class="p">(</span><span class="n">indexKey</span><span class="p">,</span> <span class="s2">"跑男"</span><span class="p">);</span> <span class="c1">-- id2 == id，但是 “跑男” 并没有覆盖 “奔跑吧兄弟”</span>
<span class="n">out</span><span class="p">:</span><span class="n">putLong</span><span class="p">(</span><span class="n">id</span><span class="p">);</span> <span class="c1">-- 返回文档 id</span>
</code></pre>

<blockquote>
<p>存储 key-&gt;value（这里将 flag 设置为 <strong>3</strong>）</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">indexKey</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">IndexKey</span><span class="p">.</span><span class="n">new</span><span class="p">();</span>
<span class="n">indexKey</span><span class="p">:</span><span class="n">setKey</span><span class="p">(</span><span class="s2">"current video"</span><span class="p">);</span>
<span class="n">myFile</span><span class="p">:</span><span class="n">write</span><span class="p">(</span><span class="n">indexKey</span><span class="p">,</span> <span class="s2">"奔跑吧兄弟"</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">myFile</span><span class="p">:</span><span class="n">write</span><span class="p">(</span><span class="n">indexKey</span><span class="p">,</span> <span class="s2">"跑男来了"</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">-- 覆盖前一个记录</span>
</code></pre>

<blockquote>
<p>上传图片，并设置&quot;文件名&quot;，之后就可以通过文件名来获取图片</p>

<p>通过此方法，模拟&quot;文件路径&quot;的访问方式</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">photoBytes</span> <span class="o">=</span> <span class="n">vars</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="kd">local</span> <span class="n">indexKey</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">IndexKey</span><span class="p">.</span><span class="n">new</span><span class="p">();</span>
<span class="n">indexKey</span><span class="p">:</span><span class="n">setKey</span><span class="p">(</span><span class="s2">"2020/0130/1720.jpg"</span><span class="p">);</span> <span class="c1">-- 以"文件名"为 key 来存储图片</span>
<span class="kd">local</span> <span class="n">id</span> <span class="o">=</span> <span class="n">photosFile</span><span class="p">:</span><span class="n">write</span><span class="p">(</span><span class="n">indexKey</span><span class="p">,</span> <span class="n">photoBytes</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">write(indexKey:IndexKey, buffer:byte[], bufferLength:ulong = MAX, offset:ulong = 0, sizeBlockMin:uint = 0, flag:uint = 0):long</code></p>

<p>根据 IndexKey 写入数据，并返回真实的记录 id（0 &lt;= id &lt; 2^32），如果返回的 id &lt; 0 则表示失败</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>indexKey</td>
<td>null</td>
<td>不能为空，参见 <a href="#IndexKey">IndexKey</a></td>
</tr>
<tr>
<td>buffer</td>
<td>null</td>
<td>不能为空。如果为空，此时将写入空的记录，如果原来该记录存在数据，将会被删除</td>
</tr>
<tr>
<td>bufferLength</td>
<td>MAX</td>
<td>默认等于 buffer.length（0 &lt;= bufferLength &lt;= buffer.length）</td>
</tr>
<tr>
<td>offset</td>
<td>0</td>
<td>起始偏移（注意：这是 id 指向的记录的偏移，而不是 buffer 的偏移）</td>
</tr>
<tr>
<td>sizeBlockMin</td>
<td>0</td>
<td>如果当前需要写入的数据长度小于 sizeBlockMin，则用字节 0 补齐（相当于为将要写的 block 分配可用空间，如果此记录的数据长度频繁增长，将会有效提高写入效率。比如：倒排文件(InvertFile)就是一个非常典型的用例）</td>
</tr>
<tr>
<td>flag</td>
<td>0</td>
<td>操作标识，有效值为 0, 1, 2, 3</td>
</tr>
</tbody></table>

<h3 id="flag">flag</h3>

<aside class="warning">

flag 应该成对使用：<code>0 :: 2 or 1 :: 3</code><br>

默认 flag = 0，<b>[唯一约束]</b><br>

如果用来存储 key->value，flag 应该为 <b>2</b> or <b>3</b>

</aside>

<table><thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>0</td>
<td>直接存储文档内容。如果已经存在该 key，将不会覆盖旧的文档内容 <strong>[唯一约束]</strong></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>在 0 的基础上覆盖写入数据。如果新的数据大于原来的数据，溢出的内容会写入到溢出的 block 里；但是，为了记录溢出的指针，旧的数据会产生数据迁移。（如果数据溢出频繁，应选择 3 的方式） <strong>[忽略唯一约束]</strong></td>
</tr>
<tr>
<td>1</td>
<td>在存储文档内容之前，先记录额外的溢出块的指针（即使此时数据尚未溢出，也会记录一个空的指针） <strong>[唯一约束]</strong></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>在 1 的基础上覆盖写入数据。不同于 2 的是，此时不会涉及到旧数据的迁移，因为，在 1 的基础上已经分配了溢出指针的空间 <strong>[忽略唯一约束]</strong></td>
</tr>
</tbody></table>

<h2 id="UniqueFile_read">read</h2>

<blockquote>
<p>根据&quot;文件名&quot;获取图片</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">indexKey</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">IndexKey</span><span class="p">.</span><span class="n">new</span><span class="p">();</span>
<span class="n">indexKey</span><span class="p">:</span><span class="n">setKey</span><span class="p">(</span><span class="s2">"2020/0130/1720.jpg"</span><span class="p">);</span>
<span class="kd">local</span> <span class="n">state</span> <span class="o">=</span> <span class="n">photosFile</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="n">indexKey</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">then</span><span class="p">;</span> <span class="c1">-- 判断是否存在数据</span>
    <span class="n">out</span><span class="p">:</span><span class="n">putBytes</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span> <span class="c1">-- 返回图片内容</span>
<span class="k">end</span><span class="p">;</span>
</code></pre>

<blockquote>
<p>获取正在播放的视频（key-&gt;value）</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">indexKey</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">IndexKey</span><span class="p">.</span><span class="n">new</span><span class="p">();</span>
<span class="n">indexKey</span><span class="p">:</span><span class="n">setKey</span><span class="p">(</span><span class="s2">"current video"</span><span class="p">);</span>
<span class="kd">local</span> <span class="n">state</span> <span class="o">=</span> <span class="n">myFile</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="n">indexKey</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">then</span><span class="p">;</span>
    <span class="n">out</span><span class="p">:</span><span class="n">putBytes</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span> <span class="c1">-- 返回正在播放的节目："跑男来了"</span>
<span class="k">end</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">read(indexKey:IndexKey, offset:ulong = 0, sizeMaxRead:uint = 0):int</code></p>

<p>根据 IndexKey 读取数据，返回成功或失败</p>

<aside class="notice">

读取出的内容缓存在全局变量 <a href="#buffer">buffer</a> 中

</aside>

<table><thead>
<tr>
<th>Parameter</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>indexKey</td>
<td>null</td>
<td>不能为空，参见 <a href="#IndexKey">IndexKey</a></td>
</tr>
<tr>
<td>offset</td>
<td>0</td>
<td>文档内的起始偏移，从此位置开始读取数据</td>
</tr>
<tr>
<td>sizeMaxRead</td>
<td>0</td>
<td>如果不为 0 则最多读取 sizeMaxRead 的数据（因为文档的总大小可能并不大于 sizeMaxRead）</td>
</tr>
</tbody></table>

<table><thead>
<tr>
<th>Return</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>成功</td>
</tr>
<tr>
<td>0</td>
<td>成功，但这是一个空记录，数据长度为 0</td>
</tr>
<tr>
<td>-7</td>
<td>该记录已经删除</td>
</tr>
<tr>
<td>-4</td>
<td>通过 open 打开的文件不存在</td>
</tr>
</tbody></table>

<h2 id="UniqueFile_remove">remove</h2>

<blockquote>
<p>删除 key 和 value</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">indexKey</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">IndexKey</span><span class="p">.</span><span class="n">new</span><span class="p">();</span>
<span class="n">indexKey</span><span class="p">:</span><span class="n">setKey</span><span class="p">(</span><span class="s2">"current video"</span><span class="p">);</span>
<span class="kd">local</span> <span class="n">state</span> <span class="o">=</span> <span class="n">myFile</span><span class="p">:</span><span class="n">remove</span><span class="p">(</span><span class="n">indexKey</span><span class="p">);</span>
<span class="n">out</span><span class="p">:</span><span class="n">putInt</span><span class="p">(</span><span class="n">state</span><span class="p">);</span> <span class="c1">-- 返回删除的状态</span>
</code></pre>

<p><code class="prettyprint">remove(indexKey:IndexKey):int</code></p>

<p>删除记录</p>

<aside class="notice">

已删除的文档空间并不会立刻回收

</aside>

<table><thead>
<tr>
<th>Return</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>成功</td>
</tr>
<tr>
<td>-7</td>
<td>该记录已经删除</td>
</tr>
<tr>
<td>-4</td>
<td>通过 open 打开的文件不存在</td>
</tr>
</tbody></table>

<h2 id="UniqueFile_hasIndex">hasIndex</h2>

<p><code class="prettyprint">hasIndex(indexKey:IndexKey):long</code></p>

<p>判断是否存在该 key，返回文档 id，如果 id &gt; 0 则存在该 key。</p>

<p>类似 <a href="#DataFile_read">read</a>，但不区分记录是否为空</p>

<h2 id="UniqueFile_removeIndex">removeIndex</h2>

<blockquote>
<p>删除 key，但不删除已经存储的 value（文档数据）</p>

<p>该 value 依然可以被访问</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">shareFile</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">UniqueFile</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="s2">"app/share"</span><span class="p">);</span>
<span class="kd">local</span> <span class="n">rawFile</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">DataFile</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">shareFile</span><span class="p">);</span>
<span class="kd">local</span> <span class="n">indexKey</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">IndexKey</span><span class="p">.</span><span class="n">new</span><span class="p">();</span>
<span class="n">indexKey</span><span class="p">:</span><span class="n">setKey</span><span class="p">(</span><span class="s2">"music"</span><span class="p">);</span>
<span class="kd">local</span> <span class="n">id</span> <span class="o">=</span> <span class="n">shareFile</span><span class="p">:</span><span class="n">hasIndex</span><span class="p">(</span><span class="n">indexKey</span><span class="p">);</span> <span class="c1">-- 删除之前，先获得文档 id</span>
<span class="n">shareFile</span><span class="p">:</span><span class="n">removeIndex</span><span class="p">(</span><span class="n">indexKey</span><span class="p">);</span> <span class="c1">-- 仅仅删除 key，但不删除数据</span>
<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">then</span><span class="p">;</span>
    <span class="n">rawFile</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="n">id</span><span class="p">);</span> <span class="c1">-- 通过 id 依然可以访问存储的文档</span>
<span class="k">end</span><span class="p">;</span>
</code></pre>

<blockquote>
<p>重新给一个已经删除的 key 进行赋值</p>

<p>但，这将不会覆盖原来尚未删除的文档</p>

<p>而是，会重新将一个新的文档与该 key 绑定</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">id</span> <span class="o">=</span> <span class="n">shareFile</span><span class="p">:</span><span class="n">hasIndex</span><span class="p">(</span><span class="n">indexKey</span><span class="p">);</span>
<span class="n">shareFile</span><span class="p">:</span><span class="n">removeIndex</span><span class="p">(</span><span class="n">indexKey</span><span class="p">);</span>
<span class="kd">local</span> <span class="n">id2</span> <span class="o">=</span> <span class="n">shareFile</span><span class="p">:</span><span class="n">write</span><span class="p">(</span><span class="n">indexKey</span><span class="p">,</span> <span class="s2">"Blank Space"</span><span class="p">);</span> <span class="c1">-- id != id2，两个文档都可以被访问</span>
</code></pre>

<p><code class="prettyprint">removeIndex(indexKey:IndexKey):int</code></p>

<p>仅仅移除 Indexkey 指定的 key，返回 1 为成功。但已经存储的 value（文档数据） 不会删除，如果需要同时删除 value，请使用 <a href="#UniqueFile_remove">remove</a></p>

<aside class="notice">

仅仅通过 removeIndex 删除 key 而不删除 value，会影响 getFileLength 的值

</aside>

<h2 id="UniqueFile_getTotalFile">getTotalFile</h2>

<p><code class="prettyprint">getTotalFile():uint</code></p>

<p>返回总文档数量（包含已经删除的）</p>

<p>同 <a href="#DataFile_getTotalFile">DataFile:getTotalFile</a></p>

<h2 id="UniqueFile_getFileLength">getFileLength</h2>

<p><code class="prettyprint">getFileLength():uint</code></p>

<p>返回有效文档数量</p>

<p>同 <a href="#DataFile_getFileLength">DataFile:getFileLength</a></p>

<h2 id="UniqueFile_getFileLengthDeleted">getFileLengthDeleted</h2>

<p><code class="prettyprint">getFileLengthDeleted():uint</code></p>

<p>返回已经删除的文档数量</p>

<p>同 <a href="#DataFile_getFileLengthDeleted">DataFile:getFileLengthDeleted</a></p>

<h2 id="UniqueFile_close">close</h2>

<p><code class="prettyprint">close():void</code></p>

<p>关闭已经打开的文件，然后可以重新打开其他文件</p>

<h2 id="UniqueFile_clear">clear</h2>

<p><code class="prettyprint">clear():void</code></p>

<p>清空 UniqueFile，这将关闭已经打开的文件并释放内存</p>

<aside class="notice">

一旦使用完该实例之后，都需要进行清空，这是良好的习惯，并且也有助于提高执行效率。

</aside>

<h1 id="InvertFile">InvertFile <em><code>class</code></em></h1>

<blockquote>
<p>由于倒排可能比较绕，所以展示一个完整的示例</p>

<p>在使用之前，先做一些准备工作（构建倒排索引）</p>

<p>1.存储新抓取的网页数据到网页集合中（获得 <code class="prettyprint">webId</code>）</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">webRawFile</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">DataFile</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="s2">"app/web"</span><span class="p">);</span>
<span class="n">webRawFile</span><span class="p">:</span><span class="n">setOne</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">-- 由于 webId 不能为 0，所以设置为从 1 开始</span>
<span class="kd">local</span> <span class="n">webId</span> <span class="o">=</span> <span class="n">webRawFile</span><span class="p">:</span><span class="n">write</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vars</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="c1">-- 存储新抓取的网页数据，并获得该 id</span>
</code></pre>

<blockquote>
<p>2.分析出网页中包含的词汇，并建立分词索引（添加新的词汇，并获得 <code class="prettyprint">wordId</code>）</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">word</span> <span class="o">=</span> <span class="s2">"爸爸去哪儿"</span><span class="p">;</span>
<span class="kd">local</span> <span class="n">indexKey</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">IndexKey</span><span class="p">.</span><span class="n">new</span><span class="p">();</span>
<span class="n">indexKey</span><span class="p">:</span><span class="n">setKey</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
<span class="kd">local</span> <span class="n">wordUniqueFile</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">UniqueFile</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="s2">"app/word"</span><span class="p">);</span> <span class="c1">-- 打开分词文件</span>
<span class="kd">local</span> <span class="n">wordId</span> <span class="o">=</span> <span class="n">wordUniqueFile</span><span class="p">:</span><span class="n">write</span><span class="p">(</span><span class="n">indexKey</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span> <span class="c1">-- 将新的词汇加入索引（由于唯一约束，所以不会出现重复记录）</span>
</code></pre>

<blockquote>
<p>3.打开倒排文件，<strong>将 <code class="prettyprint">wordId-&gt;webId</code> 录入倒排文件中</strong></p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">sizeBlockMin</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
<span class="kd">local</span> <span class="n">word2web_InvertFile</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">InvertFile</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="s2">"app/word2web"</span><span class="p">,</span> <span class="n">sizeBlockMin</span><span class="p">,</span> <span class="n">sizeBlockMin</span><span class="p">);</span> <span class="c1">-- 打开倒排文件</span>
<span class="n">word2web_InvertFile</span><span class="p">:</span><span class="n">put</span><span class="p">(</span><span class="n">wordId</span><span class="p">,</span> <span class="n">webId</span><span class="p">);</span> <span class="c1">-- 完成 wordId-&gt;webId 的倒排关系</span>
</code></pre>

<blockquote>
<p>到此为止，准备工作完成，倒排索引已经构建完成</p>

<p>搜索的过程：</p>

<p>1.先根据输入的词汇获得 <code class="prettyprint">wordId</code></p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">wordUniqueFile</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">UniqueFile</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="s2">"app/word"</span><span class="p">);</span> <span class="c1">-- 打开分词文件</span>
<span class="kd">local</span> <span class="n">indexKey</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">IndexKey</span><span class="p">.</span><span class="n">new</span><span class="p">();</span>
<span class="n">indexKey</span><span class="p">:</span><span class="n">setKey</span><span class="p">(</span><span class="s2">"爸爸去哪儿"</span><span class="p">);</span>
<span class="kd">local</span> <span class="n">wordId</span> <span class="o">=</span> <span class="n">wordUniqueFile</span><span class="p">:</span><span class="n">hasIndex</span><span class="p">(</span><span class="n">indexKey</span><span class="p">);</span> <span class="c1">-- 获得分词的 id</span>
</code></pre>

<blockquote>
<p>2.获得包含该分词的所有记录（从倒排中读取该集合中的所有 <code class="prettyprint">webId</code>）</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">sizeMaxRead</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="kd">local</span> <span class="n">state</span> <span class="o">=</span> <span class="n">word2web_InvertFile</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="n">wordId</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sizeMaxRead</span><span class="p">);</span> <span class="c1">-- 最多读取 4 的倍数长度字节</span>
<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">then</span><span class="p">;</span>
    <span class="kd">local</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
    <span class="kd">local</span> <span class="n">length</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">:</span><span class="n">readUInt</span><span class="p">();</span> <span class="c1">-- 读取有效记录数量</span>
    <span class="kd">local</span> <span class="n">lengthDeleted</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">:</span><span class="n">readUInt</span><span class="p">();</span> <span class="c1">-- 读取已经移除的记录数</span>
    <span class="kd">local</span> <span class="n">total</span> <span class="o">=</span> <span class="n">length</span> <span class="o">+</span> <span class="n">lengthDeleted</span><span class="p">;</span> <span class="c1">-- 计算总记录数量</span>
    <span class="kd">local</span> <span class="n">id</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">do</span><span class="p">;</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">total</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">bytesAvailable</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">then</span><span class="p">;</span> <span class="c1">-- 如果 buffer 中还有有效字节</span>
            <span class="n">id</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">:</span><span class="n">readUInt</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">~=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">then</span><span class="p">;</span>
                <span class="n">out</span><span class="p">:</span><span class="n">putInt</span><span class="p">(</span><span class="n">id</span><span class="p">);</span> <span class="c1">-- 返回不为 0 的 id 记录</span>
            <span class="k">end</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">then</span><span class="p">;</span>
            <span class="n">word2web_InvertFile</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="n">wordId</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="nb">math.min</span><span class="p">(</span><span class="n">sizeMaxRead</span><span class="p">,</span> <span class="n">total</span> <span class="o">*</span> <span class="mi">4</span><span class="p">));</span> <span class="c1">-- 从 offset 位置开始分片读取</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">buffer</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
        <span class="k">end</span><span class="p">;</span>
    <span class="k">end</span><span class="p">;</span>
<span class="k">end</span><span class="p">;</span>
</code></pre>

<blockquote>
<p>搜索过程结束</p>
</blockquote>

<p>倒排文件：用来存储指向一个 [相同属性] 的所有记录 ID</p>

<p>比如：为搜索引擎构建倒排索引</p>

<p><strong>InvertFile 通过非常简单的方法来使这种操作变得非常简单</strong></p>

<aside class="warning">

与 InvertFile 相关的 DataFile 需要设置 <a href="#DataFile_setOne">setOne(true)</a>。<b>因为 InvertFile 里的 id 不能为 0。</b>

</aside>

<h2 id="InvertFile_new">new <em><code>constructor</code></em></h2>

<p><code class="prettyprint">new(path:String = null, sizeBlockMin:uint = 0, sizeBlockMinFirst:uint = 0):InvertFile</code></p>

<p>参数同 <a href="#InvertFile_open">open</a></p>

<h2 id="InvertFile_open">open</h2>

<blockquote>
<p>打开倒排文件</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">sizeBlockMin</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
<span class="kd">local</span> <span class="n">word2web_InvertFile</span> <span class="o">=</span> <span class="n">LFS</span><span class="p">.</span><span class="n">InvertFile</span><span class="p">.</span><span class="n">new</span><span class="p">();</span> <span class="c1">-- 分词指向网页的倒排表</span>
<span class="n">webInvertFile</span><span class="p">:</span><span class="n">open</span><span class="p">(</span><span class="s2">"app/word2web"</span><span class="p">,</span> <span class="n">sizeBlockMin</span><span class="p">,</span> <span class="n">sizeBlockMin</span><span class="p">);</span>
</code></pre>

<p><code class="prettyprint">open(path:String, sizeBlockMin:uint = 0, sizeBlockMinFirst:uint = 0):void</code></p>

<p>打开文件，请确保 sizeBlockMin, sizeBlockMinFirst 的值是有效的</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>path</td>
<td>null</td>
<td>文件路径</td>
</tr>
<tr>
<td>sizeBlockMin</td>
<td>0</td>
<td>每次需要分配的最小块大小，4 的倍数（因为倒排文件里的记录 id 是不断增长的，所以预先分配合适的空间，当此空间写满之后，会继续分配另一个块空间）</td>
</tr>
<tr>
<td>sizeBlockMinFirst</td>
<td>0</td>
<td>第一次需要分配的空间（第一次会额外分配 8 字节来记录有效数量和删除的数量，所以可以选择使用 sizeBlockMinFirst = sizeBlockMin + 8，也可以和 sizeBlockMin 相等）。另一种方案是：如果可以确定该倒排记录会在初期增长迅速，但达到一定程度时将不会频繁增长，那么这种情况可以将 sizeBlockMinFirst 设置为比 sizeBlockMin 大得多的值。</td>
</tr>
</tbody></table>

<h2 id="InvertFile_put">put</h2>

<p><code class="prettyprint">put(key:uint, id:uint, sizeBlockMin:uint = null, sizeBlockMinFirst:uint = null):int</code></p>

<p>添加 id 到 key 指向的倒排记录中，返回 &gt;= 1 为成功。</p>

<p>参见 <a href="#InvertFile">example</a> 中的构建倒排索引过程。</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>key</td>
<td>0</td>
<td>[相同属性]的文档 id。一般情况下为通过 UniqueFile 生成的 id（即先将单词通过 UniqueFile 生成唯一索引，获得返回的 id 即为 key。所以 InvertFile 通常和 UniqueFile 一起使用）</td>
</tr>
<tr>
<td>id</td>
<td>0</td>
<td>id 不能为 0。id 为另一个文件中的文档 id（比如将抓取的网页记录到一个 DataFile 中，并获得返回的 id）。</td>
</tr>
<tr>
<td>sizeBlockMin</td>
<td>null</td>
<td>若不传此参数将使用 open 时的数值</td>
</tr>
<tr>
<td>sizeBlockMinFirst</td>
<td>null</td>
<td>若不传此参数将使用 open 时的数值</td>
</tr>
</tbody></table>

<h2 id="InvertFile_has">has</h2>

<p><code class="prettyprint">has(key:uint, id:uint):long</code></p>

<p>判断 key 的集合中是否包含该 id，返回 id &gt; 0 为成功。</p>

<h2 id="InvertFile_remove">remove</h2>

<p><code class="prettyprint">remove(key:uint, id:uint):int</code></p>

<p>从 key 的集合中移除该 id，返回 1 为成功</p>

<h2 id="InvertFile_read">read</h2>

<blockquote>
<p>实际应用中，由于数组可能非常大，那么分片读取来提高效率</p>
</blockquote>
<pre class="highlight lua"><code><span class="kd">local</span> <span class="n">sizeMaxRead</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="kd">local</span> <span class="n">state</span> <span class="o">=</span> <span class="n">word2web_InvertFile</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="n">wordId</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sizeMaxRead</span><span class="p">);</span> <span class="c1">-- 最多读取 4 的倍数长度字节</span>
<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">then</span><span class="p">;</span>
    <span class="kd">local</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
    <span class="kd">local</span> <span class="n">length</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">:</span><span class="n">readUInt</span><span class="p">();</span> <span class="c1">-- 读取有效记录数量</span>
    <span class="kd">local</span> <span class="n">lengthDeleted</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">:</span><span class="n">readUInt</span><span class="p">();</span> <span class="c1">-- 读取已经移除的记录数</span>
    <span class="kd">local</span> <span class="n">total</span> <span class="o">=</span> <span class="n">length</span> <span class="o">+</span> <span class="n">lengthDeleted</span><span class="p">;</span> <span class="c1">-- 计算总记录数量</span>
    <span class="kd">local</span> <span class="n">id</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">do</span><span class="p">;</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">total</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">bytesAvailable</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">then</span><span class="p">;</span> <span class="c1">-- 如果 buffer 中还有有效字节</span>
            <span class="n">id</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">:</span><span class="n">readUInt</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">~=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">then</span><span class="p">;</span>
                <span class="n">out</span><span class="p">:</span><span class="n">putInt</span><span class="p">(</span><span class="n">id</span><span class="p">);</span> <span class="c1">-- 返回不为 0 的 id 记录</span>
            <span class="k">end</span><span class="p">;</span>
        <span class="k">else</span><span class="p">;</span>
            <span class="n">word2web_InvertFile</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="n">wordId</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="nb">math.min</span><span class="p">(</span><span class="n">sizeMaxRead</span><span class="p">,</span> <span class="n">total</span> <span class="o">*</span> <span class="mi">4</span><span class="p">));</span> <span class="c1">-- 从 offset 位置开始分片读取</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">buffer</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
        <span class="k">end</span><span class="p">;</span>
    <span class="k">end</span><span class="p">;</span>
<span class="k">end</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">read(key:long, offset:ulong = 0, sizeMaxRead:uint = 0):int</code></p>

<p>同 <a href="#DataFile_read">DataFile:read</a></p>

<p>读取 key 的数组集合</p>

<p>InvertFile 中的数据格式为 uint 数组：<strong>[ length, lengthDeleted, id1, id2, id3, <code class="prettyprint">...</code> ]</strong><br></p>

<p>取出数组中有效 id 的步骤为：</p>

<ol>
<li>首先通过 <code class="prettyprint">total = length + lengthDeleted</code> 计算出总的记录数量。（计算 total 非常重要的，因为 <code class="prettyprint">...</code> 中可能含有值为 0 的 id，这就是为什么 id 需要从 1 开始的原因。）</li>
<li>循环遍历数组的每一项 id（从第 3 个开始），判断该 id &gt; 0，将 total 减 1。</li>
<li>重复 2 的步骤，直到 total 等于 0。</li>
</ol>

<aside class="notice">

实际应用中，由于数组可能非常大，无法一次性读入内存。所以使用 offset 和 sizeMaxRead 分片读入来提高效率。或者可以使用多线程来分片读取。

</aside>

<h2 id="InvertFile_close">close</h2>

<p><code class="prettyprint">close():void</code></p>

<p>关闭已经打开的文件，然后可以重新打开其他文件</p>

<h2 id="InvertFile_clear">clear</h2>

<p><code class="prettyprint">clear():void</code></p>

<p>清空 InvertFile，这将关闭已经打开的文件并释放内存</p>

<aside class="notice">

一旦使用完该实例之后，都需要进行清空，这是良好的习惯，并且也有助于提高执行效率。

</aside>

<h1 id="IndexKey">IndexKey <em><code>Class</code></em></h1>

<p>索引 key：将字符串或字节数组转换成可被索引的哈希</p>

<h2 id="IndexKey_new">new <em><code>constructor</code></em></h2>

<p><code class="prettyprint">new():IndexKey</code></p>

<h2 id="IndexKey_setKey">setKey</h2>

<p><code class="prettyprint">setKey(key:Bytes, size:uint = MAX):IndexKey</code></p>

<p>将 key 进行哈希，该操作会获得两个哈希值，参见下面的方法重载。</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>key</td>
<td>null</td>
<td>参见 key 的类型</td>
</tr>
<tr>
<td>size</td>
<td>MAX</td>
<td>该 key 中从 0 开始的字节长度（默认为 key 的长度）</td>
</tr>
</tbody></table>

<h3 id="key">key 的类型</h3>

<table><thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>String</td>
<td>普通字符串</td>
</tr>
<tr>
<td>Bytes</td>
<td>客户端传入的原始字节</td>
</tr>
<tr>
<td>ByteArray</td>
<td>字节数组（从该 position 向后的字节）</td>
</tr>
</tbody></table>

<p><code class="prettyprint">setKey(hashIndex:ulong, hash2:ulong):IndexKey</code></p>

<p>方法重载：通过此方法，用户可以设计自己的哈希方法。</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>hashIndex</td>
<td>0</td>
<td>通过 index = hashIndex % length 来计算出索引位置</td>
</tr>
<tr>
<td>hash2</td>
<td>0</td>
<td>当 index 出现冲突时，用来进行区分的第二个哈希（注：hashIndex 不能和 hash2 相同）</td>
</tr>
</tbody></table>

<aside class="warning">

hashIndex 不能和 hash2 相同，因为通过 hashIndex 计算出相同 index 的概率太高。

</aside>

<h2 id="IndexKey_setLength">setLength</h2>

<p><code class="prettyprint">setLength(length:uint):IndexKey</code></p>

<p>设置哈希表的长度。length 参与 setKey 的计算，所以需要在 setKey 之前设置。（可以适当设置一个较小的值）</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>length</td>
<td>0</td>
<td>当 length 为 0 时，length = 5592405（即刚好占用一个 64M 的文件：2^26 / 12 = 5592405）</td>
</tr>
</tbody></table>

<h2 id="IndexKey_clear">clear</h2>

<p><code class="prettyprint">clear():void</code></p>

<p>清空 IndexKey</p>

<aside class="notice">

一旦使用完该实例之后，都需要进行清空，这是良好的习惯，并且也有助于提高执行效率。

</aside>

<h1 id="ByteArray">ByteArray <em><code>Class</code></em></h1>

<p>字节数组：提供对原始字节的高级读写</p>

<h2 id="ByteArray_new">new <em><code>constructor</code></em></h2>

<p><code class="prettyprint">new():ByteArray</code></p>

<h2 id="ByteArray_bytesAvailable">bytesAvailable <em><code>property</code></em></h2>

<p><code class="prettyprint">bytesAvailable:uint</code> [read-only]</p>

<p>可从字节数组的当前位置到数组末尾读取的数据的字节数。</p>

<p>每次访问 ByteArray 对象时，将 bytesAvailable 属性与读取方法结合使用，以确保读取有效的数据。</p>

<h2 id="ByteArray_endian">endian <em><code>property</code></em></h2>

<p><code class="prettyprint">endian:int</code></p>

<p>更改或读取数据的字节顺序；BIG_ENDIAN: 1 或 LITTLE_ENDIAN: 0。默认值为 BIG_ENDIAN。</p>

<h2 id="ByteArray_length">length <em><code>property</code></em></h2>

<p><code class="prettyprint">length:uint</code></p>

<p>ByteArray 对象的长度（以字节为单位）。</p>

<p>如果将长度设置为大于当前长度的值，则用零填充字节数组的右侧。</p>

<p>如果将长度设置为小于当前长度的值，将会截断该字节数组。</p>

<h2 id="ByteArray_position">position <em><code>property</code></em></h2>

<p><code class="prettyprint">position:uint</code></p>

<p>设置或返回 ByteArray 中的当前位置。下一次调用读取方法时将在此位置开始读取，或者下一次调用写入方法时将在此位置开始写入。</p>

<h2 id="ByteArray_writeBytes">writeBytes</h2>

<p><code class="prettyprint">writeBytes(bytes:Bytes, offset:uint = 0, length:uint = 0):void</code></p>

<p>将字节数组 bytes（起始偏移量为 offset）中包含 length（默认为 bytes 的长度）个字节的字节序列写入 ByteArray。</p>

<h3 id="bytes">bytes 的类型</h3>

<table><thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>String</td>
<td>普通字符串</td>
</tr>
<tr>
<td>Bytes</td>
<td>客户端传入的原始字节</td>
</tr>
<tr>
<td>ByteArray</td>
<td>字节数组（从该 position 向后的字节）</td>
</tr>
</tbody></table>

<h2 id="ByteArray_writeBoolean">writeBoolean</h2>

<p><code class="prettyprint">writeBoolean(value:Boolean):void</code></p>

<h2 id="ByteArray_writeByte">writeByte</h2>

<p><code class="prettyprint">writeByte(value:byte):void</code></p>

<h2 id="ByteArray_writeShort">writeShort</h2>

<p><code class="prettyprint">writeShort(value:short):void</code></p>

<h2 id="ByteArray_writeInt">writeInt</h2>

<p><code class="prettyprint">writeInt(value:int):void</code></p>

<h2 id="ByteArray_writeLong">writeLong</h2>

<p><code class="prettyprint">writeLong(value:long):void</code></p>

<h2 id="ByteArray_writeFloat">writeFloat</h2>

<p><code class="prettyprint">writeFloat(value:float):void</code></p>

<h2 id="ByteArray_writeDouble">writeDouble</h2>

<p><code class="prettyprint">writeDouble(value:double):void</code></p>

<h2 id="ByteArray_readBytes">readBytes</h2>

<p><code class="prettyprint">readBytes(bytes:ByteArray, offset:uint = 0, length:uint = 0):void</code></p>

<p>在 bytes 中 offset 指定的位置开始，写入 length（默认为：bytesAvailable）长度的字节。</p>

<p><code class="prettyprint">readBytes(length:uint = 0):String</code></p>

<p>方法重载：读取 length（默认为：bytesAvailable）指定长度的字节，作为字符串返回。</p>

<h2 id="ByteArray_readBoolean">readBoolean</h2>

<p><code class="prettyprint">readBoolean():Boolean</code></p>

<h2 id="ByteArray_readByte">readByte</h2>

<p><code class="prettyprint">readByte():byte</code></p>

<h2 id="ByteArray_readUByte">readUByte</h2>

<p><code class="prettyprint">readUByte():ubyte</code></p>

<h2 id="ByteArray_readShort">readShort</h2>

<p><code class="prettyprint">readShort():short</code></p>

<h2 id="ByteArray_readUShort">readUShort</h2>

<p><code class="prettyprint">readUShort():ushort</code></p>

<h2 id="ByteArray_readInt">readInt</h2>

<p><code class="prettyprint">readInt():int</code></p>

<h2 id="ByteArray_readUInt">readUInt</h2>

<p><code class="prettyprint">readUInt():uint</code></p>

<h2 id="ByteArray_readLong">readLong</h2>

<p><code class="prettyprint">readLong():long</code></p>

<h2 id="ByteArray_readFloat">readFloat</h2>

<p><code class="prettyprint">readFloat():float</code></p>

<h2 id="ByteArray_readDouble">readDouble</h2>

<p><code class="prettyprint">readDouble():double</code></p>

<h2 id="ByteArray_clear">clear</h2>

<p><code class="prettyprint">clear():void</code></p>

<p>清空 ByteArray</p>

<aside class="notice">

一旦使用完该实例之后，都需要进行清空，这是良好的习惯，并且也有助于提高执行效率。

</aside>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="lua">lua</a>
          </div>
      </div>
    </div>
  </body>
</html>
